use std::mem::transmute;

use crate::{
    bitboard::{BitBoard, BB64},
    square::Square,
};

const ATTACK_COUNT: usize = 87988;
const ATTACKS: [BitBoard; ATTACK_COUNT] =
    unsafe { transmute(*include_bytes!("../../../bins/sliders.bin")) };

/// Black magics, contain the magic number and attack table index
#[repr(C)]
#[derive(PartialEq, Eq, PartialOrd, Clone, Copy, Debug, Default)]
struct BlackMagic {
    magic: u64,
    index: u64,
}

/// Pre-initialized "dummy" Magics table.
/// These tables do not have any initialization code, and take their values from the .bin files
/// generated by the build script. For the initialization, refer to the build_deps module.
///
/// Carp uses Black Magic BitBoards found by Volker Annuss and Niklas Fiekas
/// https://www.talkchess.com/forum3/viewtopic.php?f=7&t=64790&sid=0cd7ee9568af2cbd4c7297b348b5a850
#[repr(C)]
#[derive(Clone, Debug)]
pub struct Magics {
    magics: [BlackMagic; Square::COUNT],
    notmasks: BB64,
    shift: usize,
}

impl Magics {
    pub const BISHOP: Self =
        unsafe { transmute(*include_bytes!("../../../bins/bishop_magics.bin")) };
    pub const ROOK: Self = unsafe { transmute(*include_bytes!("../../../bins/rook_magics.bin")) };

    /// Get magic index for the tables given the blocker board and source square
    const fn magic_map(&self, square: Square, blockers: BitBoard) -> usize {
        let sq = square as usize;
        let bm = self.magics[sq];

        let mut relevant_occs = blockers.0 | self.notmasks[sq].0;
        relevant_occs = relevant_occs.wrapping_mul(bm.magic);
        relevant_occs >>= 64 - self.shift;

        (relevant_occs + bm.index) as usize
    }

    /// Get slider attack from square with given blockers
    /// SAFETY: Magic_map is guaranteed to fall within ATTACKS bounds because of the way
    ///         magics are initialized.
    pub fn attacks(&self, square: Square, blockers: BitBoard) -> BitBoard {
        unsafe { *ATTACKS.get_unchecked(self.magic_map(square, blockers)) }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn bishop_magic_attacks() {
        let bb1 = Magics::BISHOP.attacks(Square::E4, BitBoard(1161084283129857));
        let bb2 = Magics::BISHOP.attacks(Square::B7, BitBoard(35253091631104));

        println!("{bb1}\n{bb2}\n");

        assert_eq!(bb1, BitBoard(1169881047499265));
        assert_eq!(bb2, BitBoard(68854022149));
    }

    #[test]
    fn rook_magic_attacks() {
        let bb1 = Magics::ROOK.attacks(Square::A8, BitBoard(1099511627778));
        let bb2 = Magics::ROOK.attacks(Square::E4, BitBoard(76561335399223296));

        println!("{bb1}\n{bb2}\n");

        assert_eq!(bb1, BitBoard(1103823438082));
        assert_eq!(bb2, BitBoard(4521393946365952));
    }
}
