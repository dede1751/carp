use std::mem::transmute;

use crate::{
    bitboard::{BitBoard, BB64},
    square::Square,
};

const ATTACK_COUNT: usize = 87988;
const ATTACKS: [BitBoard; ATTACK_COUNT] =
    unsafe { transmute(*include_bytes!("../../../bins/attacks.bin")) };

/// Black magics, contain the magic number and attack table index
#[repr(C)]
#[derive(PartialEq, Eq, PartialOrd, Clone, Copy, Debug, Default)]
struct BlackMagic {
    magic: u64,
    index: u64,
}

/// Pre-initialized "dummy" Magics table.
/// These tables do not have any initialization code, and take their values from the .bin files
/// generated by the build script. For the initialization, refer to the build_deps module.
#[repr(C)]
#[derive(Clone, Debug)]
pub struct Magics {
    magics: [BlackMagic; Square::COUNT],
    notmasks: BB64,
    shift: usize,
}

impl Magics {
    pub const BISHOP: Self =
        unsafe { transmute(*include_bytes!("../../../bins/bishop_magics.bin")) };
    pub const ROOK: Self = unsafe { transmute(*include_bytes!("../../../bins/rook_magics.bin")) };

    /// Get magic index for the tables given the blocker board and source square
    const fn magic_map(&self, square: Square, blockers: BitBoard) -> usize {
        let sq = square as usize;
        let bm = self.magics[sq];

        let mut relevant_occs = blockers.0 | self.notmasks[sq].0;
        relevant_occs = relevant_occs.wrapping_mul(bm.magic);
        relevant_occs >>= 64 - self.shift;

        (relevant_occs + bm.index) as usize
    }

    /// Get slider attack from square with given blockers
    pub const fn attacks(&self, square: Square, blockers: BitBoard) -> BitBoard {
        ATTACKS[self.magic_map(square, blockers)]
    }
}
